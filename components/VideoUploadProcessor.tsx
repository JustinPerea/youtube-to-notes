'use client';

import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import PresentationSlides from './PresentationSlides';
import SimplePdfDownload from './SimplePdfDownload';
import ProcessingStatusBar from './ProcessingStatusBar';
import { useSession } from 'next-auth/react';
import { extractVideoId, parseYouTubeTimestampLink } from '@/lib/utils/youtube';
import { ResultsCompletionAd } from './ads/FreeUserAdBanner';
import { convertTimestampsToLinks } from '@/lib/timestamps/utils';
import { TimestampButton } from './ui/TimestampButton';
// Simplified UI - removed complex quality indicators

interface ProcessingResult {
  title: string;
  content: string;
  template: string;
  processingMethod?: 'hybrid' | 'transcript-only' | 'video-only' | 'auto' | 'fallback';
  dataSourcesUsed?: string[];
  contentAnalysis?: {
    type: string;
    complexity: string;
    confidence: number;
    cognitiveLoad?: string;
    readabilityLevel?: string;
  };
  quality?: {
    formatCompliance: number;
    nonConversationalScore: number;
    contentAdaptation: string;
    cognitiveOptimization?: string;
  };
  verbosityVersions?: {
    brief: string;
    standard: string;
    comprehensive: string;
  };
  allVerbosityLevels?: {
    brief: string;
    standard: string;
    comprehensive: string;
  };
  transcript?: {
    fullText: string;
    cleanedText: string;
    segments: Array<{
      text: string;
      duration: number;
      offset: number;
    }>;
    metadata?: {
      videoId: string;
      hasAutoGeneratedCaptions: boolean;
      language: string;
      duration: number;
      wordCount: number;
    };
  };
  processingStats?: {
    method: 'transcript' | 'video' | 'hybrid';
    tokenUsage?: string;
    costOptimization?: string;
    apiCalls?: number;
    processingTime?: number;
    transcriptWordCount?: number;
  };
  tokensUsed?: number;
  noteId?: string;
  autoSaved?: boolean;
}

// NEW: Individual template status management (Phase 1 - Step 1.3)
interface TemplateStatus {
  template: string;
  status: 'pending' | 'processing' | 'complete' | 'error';
  progress: number;
  result?: ProcessingResult;
  error?: string;
  startedAt?: number;
  completedAt?: number;
  noteId?: string;
  autoSaved?: boolean;
}

interface VideoUploadProcessorProps {
  videoUrl: string;
  selectedTemplates: string[];
  processingMode?: 'auto' | 'hybrid' | 'transcript-only' | 'video-only';
  onProcessingComplete?: () => void;
  onClose?: () => void;
  onVideoContextUpdate?: (context: any) => void; // ChatbotVideoContext from types
  onProcessedNotesUpdate?: (notes: string) => void;
}

export function VideoUploadProcessor({ 
  videoUrl, 
  selectedTemplates,
  processingMode = 'hybrid',
  onProcessingComplete,
  onClose,
  onVideoContextUpdate,
  onProcessedNotesUpdate
}: VideoUploadProcessorProps) {
  const { data: session } = useSession();
  const [isProcessing, setIsProcessing] = useState(false);
  const [results, setResults] = useState<ProcessingResult[]>([]);
  const [currentProcessingIndex, setCurrentProcessingIndex] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [showMarkdown, setShowMarkdown] = useState(true);
  const [currentVerbosity, setCurrentVerbosity] = useState<'brief' | 'standard' | 'comprehensive'>('standard');
  const [isSavingNote, setIsSavingNote] = useState(false);
  const [saveNoteMessage, setSaveNoteMessage] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [canRetry, setCanRetry] = useState(false);
  const [showTranscript, setShowTranscript] = useState(false);
  const [processingStatus, setProcessingStatus] = useState<string>('Initializing...');
  const [processingStepsList, setProcessingStepsList] = useState<string[]>([]);
  const [progress, setProgress] = useState(0);
  const [estimatedTimeRemaining, setEstimatedTimeRemaining] = useState<number | null>(null);
  const [startTime, setStartTime] = useState<number | null>(null);
  const [videoMetadata, setVideoMetadata] = useState<{
    title?: string;
    duration?: string;
    channel?: string;
    publishedAt?: string;
    description?: string;
  } | null>(null);
  const [processingSteps, setProcessingSteps] = useState<{
    notes: { status: 'pending' | 'processing' | 'complete' | 'error'; message?: string; error?: string }
  }>({
    notes: { status: 'pending' }
  });
  
  // NEW: Per-template status tracking (Phase 1 - Step 1.3)
  const [templateStatuses, setTemplateStatuses] = useState<Record<string, TemplateStatus>>({});
  
  // NEW: Progress aggregation from concurrent requests (Phase 1 - Step 1.2)
  const [progressStates, setProgressStates] = useState<Record<string, number>>({});

  const [streamingPreferred, setStreamingPreferred] = React.useState(
    process.env.NEXT_PUBLIC_FORCE_STREAMING === 'true'
  );
  const [streamingResolved, setStreamingResolved] = React.useState(
    process.env.NEXT_PUBLIC_FORCE_STREAMING === 'true' || process.env.NEXT_PUBLIC_DISABLE_STREAMING === 'true'
  );

  React.useEffect(() => {
    if (process.env.NEXT_PUBLIC_FORCE_STREAMING === 'true') {
      setStreamingPreferred(true);
      setStreamingResolved(true);
      return;
    }
    if (process.env.NEXT_PUBLIC_DISABLE_STREAMING === 'true') {
      setStreamingPreferred(false);
      setStreamingResolved(true);
      return;
    }
    if (typeof window === 'undefined') return;
    const hostname = window.location.hostname;
    setStreamingPreferred(hostname !== 'localhost' && hostname !== '127.0.0.1');
    setStreamingResolved(true);
  }, []);

  const lastStatusRef = React.useRef<string | null>(null);
  
  // Simplified UI - removed unused state variables

  // Helper function to update specific processing step
  const updateProcessingStep = (step: 'notes', updates: { status: 'pending' | 'processing' | 'complete' | 'error', message?: string, error?: string }) => {
    setProcessingSteps(prev => ({
      ...prev,
      [step]: { ...prev[step], ...updates }
    }));
  };

  // NEW: Helper function to update template status (Phase 1 - Step 1.3)
  const updateTemplateStatus = (template: string, updates: Partial<TemplateStatus>) => {
    setTemplateStatuses(prev => ({
      ...prev,
      [template]: { ...prev[template], template, ...updates }
    }));
  };

  // NEW: Progress aggregation helper functions (Phase 1 - Step 1.2)
  const updateTemplateProgress = (template: string, progress: number) => {
    setProgressStates(prev => ({ ...prev, [template]: progress }));
  };

  const calculateOverallProgress = () => {
    const progressValues = Object.values(progressStates);
    return progressValues.length > 0 
      ? progressValues.reduce((sum, p) => sum + p, 0) / progressValues.length 
      : 0;
  };

  type StreamCallbacks = {
    onStatus?: (message?: string, progress?: number) => void;
    onProgress?: (progress: number) => void;
  };

  const buildResultFromStream = (payload: any, templateId: string): ProcessingResult => {
    const baseContent = typeof payload?.content === 'string' ? payload.content : '';
    const normalizedContent = baseContent
      ? convertTimestampsToLinks(baseContent, videoUrl)
      : baseContent;

    const allVerbosity = payload?.allVerbosityLevels || payload?.verbosityVersions || {
      brief: normalizedContent,
      standard: normalizedContent,
      comprehensive: normalizedContent,
    };

    return {
      title: payload?.title || `Notes from ${videoUrl}`,
      content: normalizedContent,
      template: templateId,
      processingMethod: payload?.processingMethod || 'async-stream',
      dataSourcesUsed: payload?.dataSourcesUsed || ['Gemini Streaming'],
      contentAnalysis: payload?.contentAnalysis,
      quality: payload?.quality,
      verbosityVersions: allVerbosity,
      allVerbosityLevels: allVerbosity,
      transcript: payload?.transcript,
      processingStats: payload?.processingStats,
      tokensUsed: payload?.tokensUsed ?? payload?.tokenUsage,
      noteId: payload?.noteId,
      autoSaved: !!payload?.noteId,
    };
  };

  const processTemplateStandard = async (
    templateId: string,
    callbacks: StreamCallbacks = {}
  ): Promise<ProcessingResult> => {
    const response = await fetch('/api/videos/process', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        videoUrl: videoUrl.trim(),
        selectedTemplate: templateId,
        processingMode,
      }),
    });

    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || `Failed to process ${templateId} format`);
    }

    callbacks.onProgress?.(100);
    return data as ProcessingResult;
  };

  const processTemplateStreaming = async (
    templateId: string,
    callbacks: StreamCallbacks = {}
  ): Promise<ProcessingResult> => {
    const requestPayload = {
      videoUrl: videoUrl.trim(),
      selectedTemplate: templateId,
      processingMode,
      forceAsync: true,
    };

    const response = await fetch('/api/videos/process-async', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify(requestPayload),
    });

    const contentType = response.headers.get('content-type') || '';

    if (!response.ok) {
      let errorDetail = 'Failed to process video asynchronously';
      try {
        const data = await response.json();
        errorDetail = data.error || errorDetail;
      } catch (e) {
        // ignore JSON parsing errors
      }
      throw new Error(errorDetail);
    }

    if (!contentType.includes('text/event-stream')) {
      const data = await response.json();

      if (data?.redirect) {
        return processTemplateStandard(templateId, callbacks);
      }

      if (data?.error) {
        throw new Error(data.error);
      }

      callbacks.onProgress?.(100);
      return data as ProcessingResult;
    }

    const reader = response.body?.getReader?.();

    const decoder = new TextDecoder();
    let buffer = '';
    let finalResult: ProcessingResult | null = null;

    const handleEventPayload = (payloadStr: string) => {
      if (!payloadStr) return;

      let eventData: any;
      try {
        eventData = JSON.parse(payloadStr);
      } catch (error) {
        console.warn('Failed to parse SSE payload', error, { payload: payloadStr });
        return;
      }

      if (eventData.type === 'status') {
        callbacks.onStatus?.(eventData.message, eventData.progress);
        if (typeof eventData.progress === 'number') {
          callbacks.onProgress?.(eventData.progress);
        }
      } else if (eventData.type === 'result') {
        const resultPayload = eventData.result || eventData;
        finalResult = buildResultFromStream(resultPayload, templateId);
      } else if (eventData.type === 'error') {
        console.error('Streaming error event', eventData);
        throw new Error(eventData.message || 'Streaming error occurred');
      }
    };

    try {
      if (!reader) {
        console.warn('ReadableStream reader not available; buffering full SSE response');
        const fullBody = await response.text();
        fullBody
          .split('\n\n')
          .map(chunk => chunk.trim())
          .filter(Boolean)
          .forEach(chunk => {
            const dataLine = chunk
              .split('\n')
              .find(line => line.startsWith('data:'));
            if (!dataLine) return;
            const payloadStr = dataLine.replace(/^data:\s*/, '');
            handleEventPayload(payloadStr);
          });
      } else {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });

          let boundary = buffer.indexOf('\n\n');
          while (boundary !== -1) {
            const rawEvent = buffer.slice(0, boundary).trim();
            buffer = buffer.slice(boundary + 2);
            boundary = buffer.indexOf('\n\n');

            if (!rawEvent.startsWith('data:')) continue;
            const payloadStr = rawEvent.replace(/^data:\s*/, '');
            handleEventPayload(payloadStr);
          }
        }

        // Flush any remaining buffered data
        const remaining = buffer.trim();
        if (remaining.startsWith('data:')) {
          handleEventPayload(remaining.replace(/^data:\s*/, ''));
        }
      }
    } catch (streamError: any) {
      console.error('Streaming handling error, aborting stream', streamError);
      throw streamError;
    }

    if (!finalResult) {
      console.error('Streaming completed without final result', { templateId, requestPayload });
      throw new Error('Streaming did not return a final result');
    }

    callbacks.onProgress?.(100);
    return finalResult;
  };

  const processTemplateRequest = (
    templateId: string,
    callbacks: StreamCallbacks = {}
  ) => {
    if (streamingPreferred) {
      return processTemplateStreaming(templateId, callbacks);
    }
    return processTemplateStandard(templateId, callbacks);
  };

  // NEW: Progressive result display (Phase 2 - Step 2.2)
  React.useEffect(() => {
    const completed = Object.values(templateStatuses).filter(s => s.status === 'complete');
    if (completed.length > 0) {
      setResults(completed.map(s => s.result!).filter(Boolean));
    }
  }, [templateStatuses]);

  // NEW: Update overall progress from aggregated template progress (Phase 1 - Step 1.2)
  React.useEffect(() => {
    const allowParallel = process.env.NEXT_PUBLIC_PARALLEL_PROCESSING === 'true' && !streamingPreferred;
    if (allowParallel && isProcessing) {
      const overallProgress = calculateOverallProgress();
      if (overallProgress > 0) {
        setProgress(Math.min(30 + overallProgress * 0.6, 95)); // Map 0-100 to 30-95 range
      }
    }
  }, [progressStates, isProcessing]);

  React.useEffect(() => {
    if (!streamingResolved) return;
    if (videoUrl && selectedTemplates.length > 0) {
      handleProcess();
    }
  }, [videoUrl, selectedTemplates, streamingResolved]);

  const addProcessingStep = (step: string, progressValue?: number) => {
    setProcessingStepsList(prev => [...prev, step]);
    setProcessingStatus(step);
    
    if (progressValue !== undefined) {
      setProgress(progressValue);
      
      // Calculate estimated time remaining
      if (startTime && progressValue > 0) {
        const elapsed = Date.now() - startTime;
        const estimated = (elapsed / progressValue) * 100 - elapsed;
        setEstimatedTimeRemaining(Math.max(0, estimated));
      }
    }
  };

  const handleProcess = async () => {
    setIsProcessing(true);
    setError(null);
    setResults([]);
    setProcessingStepsList([]);
    setProgress(0);
    setStartTime(Date.now());
    setEstimatedTimeRemaining(null);
    setCanRetry(false);
    lastStatusRef.current = null;
    
    // NEW: Initialize template statuses (Phase 1 - Step 1.3)
    const initialStatuses: Record<string, TemplateStatus> = {};
    const initialProgress: Record<string, number> = {};
    selectedTemplates.forEach(template => {
      initialStatuses[template] = {
        template,
        status: 'pending',
        progress: 0,
        startedAt: Date.now()
      };
      initialProgress[template] = 0;
    });
    setTemplateStatuses(initialStatuses);
    setProgressStates(initialProgress);

    // Initialize processing steps
    updateProcessingStep('notes', { 
      status: 'processing'
    });

    addProcessingStep('üöÄ Starting video analysis...', 2);
    addProcessingStep('üîç Validating YouTube URL...', 5);
    addProcessingStep('üìä Extracting video metadata...', 8);
    addProcessingStep('üé¨ Fetching video information...', 12);

    try {
      // Add some realistic processing steps
      await new Promise(resolve => setTimeout(resolve, 1000));
      addProcessingStep('‚úÖ Video validated successfully', 15);
      
      // Fetch video metadata early to show user what's being processed
      try {
        addProcessingStep('üìã Loading video details...', 16);
        const metadataResponse = await fetch('/api/youtube/metadata', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            url: videoUrl.trim()
          }),
        });
        
        if (metadataResponse.ok) {
          const metadata = await metadataResponse.json();
          
          // Format duration
          const duration = metadata.durationSeconds 
            ? `${Math.floor(metadata.durationSeconds / 60)}:${(metadata.durationSeconds % 60).toString().padStart(2, '0')}`
            : 'Unknown';
            
          setVideoMetadata({
            title: metadata.title || 'Unknown Title',
            duration: duration,
            channel: metadata.channelTitle || 'Unknown Channel',
            publishedAt: metadata.publishedAt ? new Date(metadata.publishedAt).toLocaleDateString() : undefined,
            description: metadata.description?.substring(0, 200) + (metadata.description?.length > 200 ? '...' : '')
          });
          
          addProcessingStep(`üì∫ "${metadata.title}" by ${metadata.channelTitle}`, 17);
          addProcessingStep(`‚è±Ô∏è Duration: ${duration}`, 18);
        }
      } catch (metadataError) {
        console.log('Metadata fetch failed, continuing with processing');
      }
      
      await new Promise(resolve => setTimeout(resolve, 800));
      addProcessingStep('üîÑ Determining optimal processing method...', 20);
      
      await new Promise(resolve => setTimeout(resolve, 600));
      addProcessingStep('üéØ Hybrid processing mode selected', 24);
      
      await new Promise(resolve => setTimeout(resolve, 500));
      addProcessingStep('üöÄ Initializing AI analysis pipeline...', 28);

      // üöÄ STEP 1: Process all selected templates
      addProcessingStep(`üìù Processing ${selectedTemplates.length} note format${selectedTemplates.length > 1 ? 's' : ''}...`, 30);
      
      let allResults: ProcessingResult[] = [];
      
      // Feature flag for parallel vs sequential processing
      const allowParallel = process.env.NEXT_PUBLIC_PARALLEL_PROCESSING === 'true' && !streamingPreferred;
      
      if (allowParallel) {
        // NEW: Parallel processing implementation
        allResults = await handleParallelProcessing(videoUrl, selectedTemplates, processingMode, addProcessingStep);
      } else {
        // ORIGINAL: Sequential processing (preserved for safe rollback)
        for (let i = 0; i < selectedTemplates.length; i++) {
          const template = selectedTemplates[i];
          setCurrentProcessingIndex(i);
          lastStatusRef.current = null;

          addProcessingStep(`üìã Processing format ${i + 1}/${selectedTemplates.length}: ${template}...`, 30 + (i * 50 / selectedTemplates.length));
          
          updateTemplateStatus(template, {
            status: 'processing',
            progress: 0,
            startedAt: Date.now()
          });
          updateTemplateProgress(template, 0);

          const templateResult = await processTemplateRequest(template, {
            onStatus: (message, progressValue) => {
              if (message && lastStatusRef.current !== message) {
                addProcessingStep(message);
                lastStatusRef.current = message;
              }
              if (typeof progressValue === 'number') {
                updateTemplateStatus(template, { progress: Math.round(progressValue) });
                updateTemplateProgress(template, progressValue);
              }
            },
            onProgress: progressValue => {
              updateTemplateStatus(template, { progress: Math.round(progressValue) });
              updateTemplateProgress(template, progressValue);
            }
          });

          allResults.push(templateResult);
          updateTemplateStatus(template, {
            status: 'complete',
            progress: 100,
            result: templateResult,
            completedAt: Date.now(),
            noteId: templateResult.noteId,
            autoSaved: !!templateResult.noteId,
          });
          updateTemplateProgress(template, 100);
          
          addProcessingStep(`‚úÖ ${template} completed`, 30 + ((i + 1) * 50 / selectedTemplates.length));
        }
      }


      // Show completion with technical details
      addProcessingStep(`üìä All ${selectedTemplates.length} format${selectedTemplates.length > 1 ? 's' : ''} completed successfully`, 90);
      
      const firstResult = allResults[0];
      if (firstResult?.processingMethod) {
        addProcessingStep(`üîß Method: ${firstResult.processingMethod}`, 92);
      }
      
      if (firstResult?.dataSourcesUsed) {
        addProcessingStep(`üìã Sources: ${firstResult.dataSourcesUsed.join(', ')}`, 94);
      }
      
      if (firstResult?.tokensUsed) {
        addProcessingStep(`‚ö° Processed ${firstResult.tokensUsed} tokens`, 96);
      }

      addProcessingStep(`‚úÖ Your ${selectedTemplates.length} note format${selectedTemplates.length > 1 ? 's are' : ' is'} ready!`, 100);

      setResults(allResults);
      setCurrentVerbosity('standard');
      
      // Mark notes as complete
      updateProcessingStep('notes', { 
        status: 'complete'
      });
      
      // Share processed notes with chatbot (use first result's content)
      if (onProcessedNotesUpdate && allResults[0]?.content) {
        onProcessedNotesUpdate(allResults[0].content);
      }
      
      // ‚úÖ Show notes immediately to user
      onProcessingComplete?.();
    } catch (err: any) {
      const errorMessage = err.message || 'Something went wrong while converting your video';
      addProcessingStep('‚ùå Conversion failed: ' + errorMessage);
      
      // Enhanced error handling with specific suggestions
      let userFriendlyError = errorMessage;
      let suggestion = '';
      
      if (errorMessage.includes('quota') || errorMessage.includes('429')) {
        userFriendlyError = 'API quota exceeded. Please try again in a few minutes.';
        suggestion = 'This is usually temporary. Please wait a few minutes and try again.';
      } else if (errorMessage.includes('timeout') || errorMessage.includes('deadline')) {
        userFriendlyError = 'Video processing timeout - this video may be too long.';
        suggestion = 'For videos longer than 1 hour, try using the async processing option.';
      } else if (errorMessage.includes('invalid') || errorMessage.includes('400')) {
        userFriendlyError = 'Invalid video URL or content not supported.';
        suggestion = 'Please ensure the YouTube URL is valid and the video is publicly accessible.';
      } else if (errorMessage.includes('size') || errorMessage.includes('too large')) {
        userFriendlyError = 'Video file is too large for processing.';
        suggestion = 'Try using the async processing option for long videos.';
      } else if (errorMessage.includes('pattern') || errorMessage.includes('parsing')) {
        userFriendlyError = 'Video content could not be analyzed.';
        suggestion = 'This may be due to video length, format, or content restrictions.';
      }
      
      setError(userFriendlyError + (suggestion ? `\n\nüí° ${suggestion}` : ''));
      
      // Enable retry for certain error types
      const retryableErrors = ['quota', '429', 'timeout', 'deadline', 'network', 'connection'];
      const isRetryable = retryableErrors.some(errorType => errorMessage.toLowerCase().includes(errorType));
      
      if (isRetryable && retryCount < 2) {
        setCanRetry(true);
      } else {
        setCanRetry(false);
      }

      const failingTemplate = selectedTemplates[currentProcessingIndex] || selectedTemplates[selectedTemplates.length - 1];
      if (failingTemplate) {
        updateTemplateStatus(failingTemplate, {
          status: 'error',
          error: userFriendlyError,
          completedAt: Date.now()
        });
      }
    } finally {
      setIsProcessing(false);
    }
  };

  const retryProcessing = () => {
    setRetryCount(prev => prev + 1);
    setCanRetry(false);
    setError(null);
    handleProcess();
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  // NEW: Parallel processing implementation
  const handleParallelProcessing = async (
    videoUrl: string,
    selectedTemplates: string[],
    processingMode: string,
    addProcessingStep: (step: string, progress?: number) => void
  ): Promise<ProcessingResult[]> => {
    // Create promises for all templates with staggered starts
    const processingPromises = selectedTemplates.map(async (template, index) => {
      try {
        // Update template status to processing
        updateTemplateStatus(template, { 
          status: 'processing', 
          progress: 0, 
          startedAt: Date.now() 
        });
        updateTemplateProgress(template, 0);

        // Stagger request starts by 150ms to reduce peak resource usage
        await new Promise(resolve => setTimeout(resolve, index * 150));
        
        addProcessingStep(`üîÑ Starting ${template} processing...`, 35 + (index * 5));
        updateTemplateStatus(template, { progress: 25 });
        updateTemplateProgress(template, 25);

        const templateResult = await processTemplateRequest(template, {
          onStatus: (_message, progressValue) => {
            if (typeof progressValue === 'number') {
              updateTemplateStatus(template, { progress: Math.round(progressValue) });
              updateTemplateProgress(template, progressValue);
            }
          },
          onProgress: progressValue => {
            updateTemplateStatus(template, { progress: Math.round(progressValue) });
            updateTemplateProgress(template, progressValue);
          }
        });

        addProcessingStep(`‚úÖ ${template} completed successfully`, 50 + (index * 10));
        
        // Update template status to complete with result
        updateTemplateStatus(template, { 
          status: 'complete', 
          progress: 100, 
          result: templateResult,
          completedAt: Date.now(),
          noteId: templateResult.noteId,
          autoSaved: !!templateResult.noteId,
        });
        updateTemplateProgress(template, 100);
        
        return {
          template,
          index,
          data: templateResult,
          status: 'success' as const,
          completedAt: Date.now()
        };
      } catch (error: any) {
        addProcessingStep(`‚ùå ${template} failed: ${error.message}`, 50 + (index * 10));
        
        // Update template status to error
        updateTemplateStatus(template, { 
          status: 'error', 
          error: error.message, 
          completedAt: Date.now() 
        });
        
        return {
          template,
          index,
          data: null,
          status: 'error' as const,
          error: error.message,
          completedAt: Date.now()
        };
      }
    });

    // Wait for all processing to complete
    const results = await Promise.allSettled(processingPromises);
    
    // Process results and handle partial success/failure
    const successfulResults: ProcessingResult[] = [];
    const failedTemplates: string[] = [];
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value.status === 'success') {
        successfulResults.push(result.value.data);
      } else {
        const template = selectedTemplates[index];
        failedTemplates.push(template);
      }
    });

    // Handle partial success scenarios
    if (failedTemplates.length > 0 && successfulResults.length > 0) {
      addProcessingStep(`‚ö†Ô∏è ${successfulResults.length}/${selectedTemplates.length} formats completed (${failedTemplates.join(', ')} failed)`, 85);
    } else if (failedTemplates.length === selectedTemplates.length) {
      throw new Error(`All formats failed to process: ${failedTemplates.join(', ')}`);
    }

    return successfulResults;
  };

  const saveNote = async () => {
    if (!session?.user?.id || results.length === 0) return;

    setIsSavingNote(true);
    setSaveNoteMessage(null);

    try {
      const unsavedResults = results.filter(result => !result.noteId);

      if (unsavedResults.length === 0) {
        setSaveNoteMessage('Notes are already saved automatically.');
        setTimeout(() => setSaveNoteMessage(null), 2500);
        return;
      }

      const updatedResults = [...results];

      // Save all generated notes
      for (const result of unsavedResults) {
        const response = await fetch('/api/notes/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            title: `${result.title} - ${result.template}`,
            content: result.content,
            templateId: result.template,
            tags: ['youtube', 'ai-generated'],
            youtubeUrl: videoUrl,
            verbosityVersions: result.allVerbosityLevels,
          }),
        });

        const data = await response.json();
        
        if (!data.success) {
          throw new Error(data.error || `Failed to save ${result.template} note`);
        }

        if (data.noteId) {
          // Update cached result with returned noteId
          const idx = updatedResults.findIndex(r => r.template === result.template);
          if (idx !== -1) {
            updatedResults[idx] = {
              ...updatedResults[idx],
              noteId: data.noteId,
              autoSaved: true,
            };
          }

          updateTemplateStatus(result.template, {
            noteId: data.noteId,
            autoSaved: true,
          });
        }
      }

      setResults(updatedResults);
      setSaveNoteMessage(`Saved ${unsavedResults.length} note${unsavedResults.length > 1 ? 's' : ''} successfully.`);
      setTimeout(() => setSaveNoteMessage(null), 3000);
    } catch (error: any) {
      setSaveNoteMessage(error.message || 'Failed to save notes');
      console.error('Error saving notes:', error);
    } finally {
      setIsSavingNote(false);
    }
  };

  const adjustVerbosity = (newVerbosity: 'brief' | 'standard' | 'comprehensive') => {
    if (results.length === 0) return;
    
    setCurrentVerbosity(newVerbosity);
    
    // Update all results with new verbosity
    const updatedResults = results.map(result => {
      const verbosityData = result.allVerbosityLevels;
      if (!verbosityData) return result;
      
      return {
        ...result,
        content: verbosityData[newVerbosity]
      };
    });
    
    setResults(updatedResults);
  };

  if (isProcessing) {

    return (
      <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
        <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-8 max-w-2xl mx-4">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[var(--accent-pink)] mx-auto mb-6"></div>
            <h3 className="text-xl font-semibold text-[var(--text-primary)] mb-2">Converting Video</h3>
            <p className="text-[var(--text-secondary)] mb-6">
              Processing your video into {selectedTemplates.length} format{selectedTemplates.length > 1 ? 's' : ''}...
            </p>
            
            {/* Show current processing template - Updated for parallel processing */}
            {selectedTemplates.length > 1 && (
              <div className="mb-4 p-3 bg-[var(--accent-pink)]/10 border border-[var(--accent-pink)]/20 rounded-lg">
                {process.env.NEXT_PUBLIC_PARALLEL_PROCESSING === 'true' ? (
                  // NEW: Per-template status display for parallel processing
                  <div className="space-y-2">
                    <p className="text-xs text-[var(--accent-pink)] font-medium mb-2">
                      Processing {selectedTemplates.length} formats concurrently:
                    </p>
                    {selectedTemplates.map(template => {
                      const status = templateStatuses[template];
                      const statusIcon = status?.status === 'complete' ? '‚úÖ' : 
                                        status?.status === 'error' ? '‚ùå' : 
                                        status?.status === 'processing' ? 'üîÑ' : '‚è≥';
                      return (
                        <div key={template} className="flex items-center justify-between text-xs">
                          <span className="text-[var(--text-primary)]">
                            {statusIcon} {template}
                          </span>
                          <span className="text-[var(--text-secondary)]">
                            {status?.progress || 0}%
                          </span>
                        </div>
                      );
                    })}
                  </div>
                ) : (
                  // ORIGINAL: Sequential processing display
                  <p className="text-sm text-[var(--accent-pink)]">
                    Processing {currentProcessingIndex + 1} of {selectedTemplates.length}: {selectedTemplates[currentProcessingIndex]}
                  </p>
                )}
              </div>
            )}
            
            {/* Simplified Progress Indicator */}
            <div className="mb-6 p-4 bg-[var(--bg-primary)] rounded-lg border border-[var(--card-border)]">
              
              {/* Overall Progress Bar */}
              <div className="w-full bg-[var(--card-border)] rounded-full h-3 mb-3 overflow-hidden">
                <div 
                  className="bg-gradient-to-r from-[var(--accent-pink)] to-[#FF8FB3] h-full rounded-full transition-all duration-500 ease-out"
                  style={{ width: `${progress}%` }}
                />
              </div>
              
              {/* Progress Info */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-[var(--text-secondary)]">{Math.round(progress)}% complete</span>
                {estimatedTimeRemaining !== null && estimatedTimeRemaining > 0 && (
                  <span className="text-[var(--text-secondary)]">
                    ~{Math.round(estimatedTimeRemaining / 1000)}s remaining
                  </span>
                )}
              </div>
            </div>

            {/* Video Metadata Display */}
            {videoMetadata && (
              <div className="mb-4 p-4 bg-[var(--bg-secondary)] rounded-lg border border-[var(--card-border)]">
                <div className="text-left space-y-2">
                  <h4 className="text-sm font-medium text-[var(--text-primary)] mb-2">Processing Video:</h4>
                  <p className="text-sm text-[var(--text-primary)] font-medium truncate" title={videoMetadata.title}>
                    üì∫ {videoMetadata.title}
                  </p>
                  <div className="flex flex-wrap gap-4 text-xs text-[var(--text-secondary)]">
                    <span>‚è±Ô∏è {videoMetadata.duration}</span>
                    <span>üìª {videoMetadata.channel}</span>
                    {videoMetadata.publishedAt && (
                      <span>üìÖ {videoMetadata.publishedAt}</span>
                    )}
                  </div>
                  {videoMetadata.description && (
                    <p className="text-xs text-[var(--text-secondary)] mt-2 leading-relaxed">
                      {videoMetadata.description}
                    </p>
                  )}
                </div>
              </div>
            )}

            {/* Simple Current Status */}
            <div className="text-center p-3 bg-[var(--accent-pink)]/10 border border-[var(--accent-pink)]/20 rounded-lg">
              <p className="text-sm text-[var(--accent-pink)] font-medium">
                {processingStatus}
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
        <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-8 max-w-md mx-4">
          <div className="text-center">
            <div className="text-4xl mb-4">‚ùå</div>
            <h3 className="text-xl font-semibold text-[var(--text-primary)] mb-2">Conversion Failed</h3>
            <p className="text-[var(--text-secondary)] mb-4 whitespace-pre-line">{error}</p>
            <div className="flex gap-3 justify-center">
              {canRetry && (
                <button
                  onClick={retryProcessing}
                  className="px-6 py-2 bg-blue-600 text-white rounded-xl font-semibold hover:bg-blue-700 transition-colors"
                >
                  üîÑ Retry ({2 - retryCount} left)
                </button>
              )}
              <button
                onClick={onClose}
                className="px-6 py-2 bg-[var(--accent-pink)] text-white rounded-xl font-semibold hover:bg-[var(--accent-pink)]/90 transition-colors"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (results.length === 0) return null;

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center overflow-y-auto">
      <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-6 max-w-4xl mx-4 my-4 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <h3 className="text-2xl font-semibold text-[var(--text-primary)]">{results[0].title}</h3>
          <button
            onClick={onClose}
            className="text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors text-2xl"
          >
            ‚úï
          </button>
        </div>
        
        {/* Format tabs when multiple results */}
        {results.length > 1 && (
          <div className="mb-6">
            {/* NEW: Partial success notification for parallel processing */}
            {process.env.NEXT_PUBLIC_PARALLEL_PROCESSING === 'true' && selectedTemplates.length > results.length && (
              <div className="mb-3 p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-lg">
                <p className="text-sm text-yellow-600">
                  ‚ö†Ô∏è {results.length} of {selectedTemplates.length} formats completed successfully. 
                  {selectedTemplates.length - results.length} format{selectedTemplates.length - results.length > 1 ? 's' : ''} failed to process.
                </p>
              </div>
            )}
            
            <div className="flex flex-wrap gap-2">
              {results.map((result, index) => (
                <button
                  key={result.template}
                  onClick={() => setCurrentProcessingIndex(index)}
                  className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                    currentProcessingIndex === index
                      ? 'bg-[var(--accent-pink)] text-white'
                      : 'bg-[var(--card-border)] text-[var(--text-secondary)] hover:bg-[var(--accent-pink)]/20'
                  }`}
                >
                  ‚úÖ {result.template}
                </button>
              ))}
            </div>
          </div>
        )}
        
        {results[currentProcessingIndex].template === 'presentation-slides' ? (
          <PresentationSlides 
            content={results[currentProcessingIndex].content}
            videoUrl={videoUrl}
          />
        ) : (
          <>
            <div className="bg-[var(--bg-primary)] rounded-xl p-6 max-h-96 overflow-y-auto mb-4">
              {showMarkdown ? (
                <div className="text-sm text-[var(--text-primary)] prose prose-invert prose-sm max-w-none">
                  <ReactMarkdown 
                    remarkPlugins={[remarkGfm]}
                    components={{
                      h1: ({children}) => <h1 className="text-xl font-bold text-[var(--text-primary)] mb-4">{children}</h1>,
                      h2: ({children}) => <h2 className="text-lg font-semibold text-[var(--text-primary)] mb-3">{children}</h2>,
                      h3: ({children}) => <h3 className="text-base font-semibold text-[var(--text-primary)] mb-2">{children}</h3>,
                      a: ({href, children}) => {
                        if (!href) {
                          return <span className="text-blue-400">{children}</span>;
                        }

                        const parsed = parseYouTubeTimestampLink(href);
                        if (parsed) {
                          return (
                            <TimestampButton
                              time={parsed.seconds}
                              videoUrl={parsed.videoUrl}
                              className="mx-1"
                            />
                          );
                        }

                        return (
                          <a
                            href={href}
                            className="text-blue-400 hover:text-blue-300 underline"
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            {children}
                          </a>
                        );
                      },
                      p: ({children}) => <p className="mb-3 text-[var(--text-primary)]">{children}</p>,
                      ul: ({children}) => <ul className="list-disc list-inside mb-3 space-y-1">{children}</ul>,
                      ol: ({children}) => <ol className="list-decimal list-inside mb-3 space-y-1">{children}</ol>,
                      li: ({children}) => <li className="ml-4">{children}</li>,
                      strong: ({children}) => <strong className="font-semibold text-[var(--text-primary)]">{children}</strong>,
                      em: ({children}) => <em className="italic">{children}</em>,
                      code: ({children}) => <code className="bg-[var(--card-border)] px-1 py-0.5 rounded text-xs">{children}</code>,
                      pre: ({children}) => <pre className="bg-[var(--card-border)] p-3 rounded-lg overflow-x-auto mb-3">{children}</pre>,
                    }}
                  >
                    {typeof results[currentProcessingIndex].content === 'string' ? results[currentProcessingIndex].content : String(results[currentProcessingIndex].content || '')}
                  </ReactMarkdown>
                </div>
              ) : (
                <pre className="text-sm text-[var(--text-primary)] whitespace-pre-wrap font-mono">
                  {results[currentProcessingIndex].content}
                </pre>
              )}
            </div>


            {/* Verbosity Controls */}
            {results[currentProcessingIndex].allVerbosityLevels && (
              <div className="mb-4 p-4 bg-[var(--bg-primary)] rounded-xl border border-[var(--card-border)]">
                <div className="flex items-center justify-between mb-3">
                  <span className="text-sm font-medium text-[var(--text-primary)]">Adjust Detail Level</span>
                  <span className="text-xs text-[var(--text-secondary)]">Current: {currentVerbosity}</span>
                </div>
                <div className="flex items-center space-x-3">
                  <button
                    onClick={() => adjustVerbosity('brief')}
                    disabled={currentVerbosity === 'brief'}
                    className="px-3 py-1.5 bg-red-500/20 border border-red-500/30 rounded-lg text-xs text-red-400 hover:bg-red-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Brief
                  </button>
                  <button
                    onClick={() => adjustVerbosity('standard')}
                    disabled={currentVerbosity === 'standard'}
                    className="px-3 py-1.5 bg-yellow-500/20 border border-yellow-500/30 rounded-lg text-xs text-yellow-400 hover:bg-yellow-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Standard ‚≠ê
                  </button>
                  <button
                    onClick={() => adjustVerbosity('comprehensive')}
                    disabled={currentVerbosity === 'comprehensive'}
                    className="px-3 py-1.5 bg-green-500/20 border border-green-500/30 rounded-lg text-xs text-green-400 hover:bg-green-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Comprehensive
                  </button>
                </div>
              </div>
            )}

            {/* Transcript Viewer */}
            {results[currentProcessingIndex].transcript && (
              <div className="mb-4 p-4 bg-[var(--bg-primary)] rounded-xl border border-[var(--card-border)]">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center space-x-2">
                    <span className="text-sm font-medium text-[var(--text-primary)]">Source Transcript</span>
                    <span className="px-2 py-1 bg-green-500/20 border border-green-500/30 rounded text-xs text-green-400">
                      {results[currentProcessingIndex].processingStats?.method === 'transcript' ? 'Used for Processing' : 'Available'}
                    </span>
                  </div>
                  <button
                    onClick={() => setShowTranscript(!showTranscript)}
                    className="text-xs text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                  >
                    {showTranscript ? 'Hide Transcript' : 'Show Transcript'}
                  </button>
                </div>
                
                {results[currentProcessingIndex].transcript.metadata && (
                  <div className="flex items-center space-x-4 mb-3 text-xs text-[var(--text-secondary)]">
                    <span>üìù {results[currentProcessingIndex].transcript.metadata.wordCount} words</span>
                    <span>‚è±Ô∏è {Math.round(results[currentProcessingIndex].transcript.metadata.duration)}s duration</span>
                    <span>üåê {results[currentProcessingIndex].transcript.metadata.language}</span>
                  </div>
                )}

                {showTranscript && (
                  <div className="max-h-64 overflow-y-auto bg-[var(--card-bg)] rounded-lg p-4 border border-[var(--card-border)]">
                    <div className="space-y-3">
                      {results[currentProcessingIndex].transcript.segments && results[currentProcessingIndex].transcript.segments.length > 0 ? (
                        <div className="space-y-2">
                          <h4 className="text-xs font-medium text-[var(--text-primary)] mb-2">Timestamped Transcript:</h4>
                          {results[currentProcessingIndex].transcript.segments.map((segment, index) => {
                            const minutes = Math.floor(segment.offset / 60);
                            const seconds = Math.floor(segment.offset % 60);
                            const timestamp = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            
                            return (
                              <div key={index} className="flex space-x-3 text-xs">
                                <span className="text-[var(--accent-pink)] font-mono min-w-[45px]">{timestamp}</span>
                                <span className="text-[var(--text-primary)]">{segment.text}</span>
                              </div>
                            );
                          })}
                        </div>
                      ) : (
                        <div>
                          <h4 className="text-xs font-medium text-[var(--text-primary)] mb-2">Full Transcript:</h4>
                          <p className="text-xs text-[var(--text-primary)] leading-relaxed">
                            {results[currentProcessingIndex].transcript.fullText}
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Action Buttons */}
            <div className="flex flex-wrap items-center justify-between gap-4 text-sm">
              <div className="flex items-center gap-4">
                <button
                  onClick={() => setShowMarkdown(!showMarkdown)}
                  className={`px-3 py-1 rounded-md transition-all duration-200 text-sm font-medium ${
                    showMarkdown 
                      ? 'text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 hover:bg-[var(--accent-pink)]/10' 
                      : 'bg-orange-500/20 text-orange-400 border border-orange-500/30 hover:bg-orange-500/30'
                  }`}
                >
                  {showMarkdown ? 'üìÑ Show Raw' : 'üîç Show Preview'}
                </button>
                <button
                  onClick={() => copyToClipboard(results[currentProcessingIndex].content)}
                  className="text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                >
                  Copy to Clipboard
                </button>
                {results[currentProcessingIndex].transcript && (
                  <button
                    onClick={() => setShowTranscript(!showTranscript)}
                    className="text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                  >
                    {showTranscript ? 'Hide Transcript' : 'View Transcript'}
                  </button>
                )}
              </div>
              
              {/* Processing Status Bar and PDF Download Section */}
              <div className="flex flex-col lg:flex-row gap-6 items-start">
                {/* Processing Status Bar */}
                <div className="lg:flex-1">
                  <h4 className="text-sm font-semibold text-[var(--text-primary)] mb-3">
                    Processing Status
                  </h4>
                  <ProcessingStatusBar 
                    steps={processingSteps}
                    compact={false}
                  />
                </div>
                
                {/* PDF Download */}
                <div className="lg:w-64 flex flex-col justify-start">
                  <SimplePdfDownload
                    content={typeof results[currentProcessingIndex].content === 'string' ? results[currentProcessingIndex].content : String(results[currentProcessingIndex].content || '')}
                    title={results[currentProcessingIndex].title}
                    template={results[currentProcessingIndex].template}
                  />
                </div>
              </div>
            </div>

            {/* Ad Banner for Free Users */}
            <ResultsCompletionAd />

            {/* Save Note */}
            {session?.user?.id && (
              <div className="mt-6 flex flex-col items-center space-y-2">
                <button
                  onClick={saveNote}
                  disabled={isSavingNote}
                  className="inline-flex items-center px-6 py-3 bg-green-600 hover:bg-green-700 disabled:bg-green-600/50 text-white font-medium rounded-lg transition-colors duration-200"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  {isSavingNote ? 'Saving...' : `Save ${results.length} Note${results.length > 1 ? 's' : ''}`}
                </button>
                {saveNoteMessage && (
                  <div className={`text-sm ${saveNoteMessage.includes('successfully') ? 'text-green-400' : 'text-red-400'}`}>
                    {saveNoteMessage}
                  </div>
                )}
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}
