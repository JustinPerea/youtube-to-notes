'use client';

import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import PresentationSlides from './PresentationSlides';
import SimplePdfDownload from './SimplePdfDownload';
import ProcessingStatusBar from './ProcessingStatusBar';
import { useSession } from 'next-auth/react';
import { extractVideoId } from '@/lib/utils/youtube';
import { ResultsCompletionAd } from './ads/FreeUserAdBanner';
// Simplified UI - removed complex quality indicators

interface ProcessingResult {
  title: string;
  content: string;
  template: string;
  processingMethod?: 'hybrid' | 'transcript-only' | 'video-only' | 'auto' | 'fallback';
  dataSourcesUsed?: string[];
  contentAnalysis?: {
    type: string;
    complexity: string;
    confidence: number;
    cognitiveLoad?: string;
    readabilityLevel?: string;
  };
  quality?: {
    formatCompliance: number;
    nonConversationalScore: number;
    contentAdaptation: string;
    cognitiveOptimization?: string;
  };
  verbosityVersions?: {
    brief: string;
    standard: string;
    comprehensive: string;
  };
  allVerbosityLevels?: {
    brief: string;
    standard: string;
    comprehensive: string;
  };
  transcript?: {
    fullText: string;
    cleanedText: string;
    segments: Array<{
      text: string;
      duration: number;
      offset: number;
    }>;
    metadata?: {
      videoId: string;
      hasAutoGeneratedCaptions: boolean;
      language: string;
      duration: number;
      wordCount: number;
    };
  };
  processingStats?: {
    method: 'transcript' | 'video' | 'hybrid';
    tokenUsage?: string;
    costOptimization?: string;
    apiCalls?: number;
    processingTime?: number;
    transcriptWordCount?: number;
  };
  tokensUsed?: number;
}

interface VideoUploadProcessorProps {
  videoUrl: string;
  selectedTemplates: string[];
  processingMode?: 'auto' | 'hybrid' | 'transcript-only' | 'video-only';
  onProcessingComplete?: () => void;
  onClose?: () => void;
  onVideoContextUpdate?: (context: any) => void; // ChatbotVideoContext from types
  onProcessedNotesUpdate?: (notes: string) => void;
}

export function VideoUploadProcessor({ 
  videoUrl, 
  selectedTemplates,
  processingMode = 'hybrid',
  onProcessingComplete,
  onClose,
  onVideoContextUpdate,
  onProcessedNotesUpdate
}: VideoUploadProcessorProps) {
  const { data: session } = useSession();
  const [isProcessing, setIsProcessing] = useState(false);
  const [results, setResults] = useState<ProcessingResult[]>([]);
  const [currentProcessingIndex, setCurrentProcessingIndex] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [showMarkdown, setShowMarkdown] = useState(true);
  const [currentVerbosity, setCurrentVerbosity] = useState<'brief' | 'standard' | 'comprehensive'>('standard');
  const [isSavingNote, setIsSavingNote] = useState(false);
  const [saveNoteMessage, setSaveNoteMessage] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const [canRetry, setCanRetry] = useState(false);
  const [showTranscript, setShowTranscript] = useState(false);
  const [processingStatus, setProcessingStatus] = useState<string>('Initializing...');
  const [processingStepsList, setProcessingStepsList] = useState<string[]>([]);
  const [progress, setProgress] = useState(0);
  const [estimatedTimeRemaining, setEstimatedTimeRemaining] = useState<number | null>(null);
  const [startTime, setStartTime] = useState<number | null>(null);
  const [videoMetadata, setVideoMetadata] = useState<{
    title?: string;
    duration?: string;
    channel?: string;
    publishedAt?: string;
    description?: string;
  } | null>(null);
  const [processingSteps, setProcessingSteps] = useState<{
    notes: { status: 'pending' | 'processing' | 'complete' | 'error'; message?: string; error?: string }
  }>({
    notes: { status: 'pending' }
  });
  // Simplified UI - removed unused state variables

  // Helper function to update specific processing step
  const updateProcessingStep = (step: 'notes', updates: { status: 'pending' | 'processing' | 'complete' | 'error', message?: string, error?: string }) => {
    setProcessingSteps(prev => ({
      ...prev,
      [step]: { ...prev[step], ...updates }
    }));
  };

  React.useEffect(() => {
    if (videoUrl && selectedTemplates.length > 0) {
      handleProcess();
    }
  }, [videoUrl, selectedTemplates]);

  const addProcessingStep = (step: string, progressValue?: number) => {
    setProcessingStepsList(prev => [...prev, step]);
    setProcessingStatus(step);
    
    if (progressValue !== undefined) {
      setProgress(progressValue);
      
      // Calculate estimated time remaining
      if (startTime && progressValue > 0) {
        const elapsed = Date.now() - startTime;
        const estimated = (elapsed / progressValue) * 100 - elapsed;
        setEstimatedTimeRemaining(Math.max(0, estimated));
      }
    }
  };

  const handleProcess = async () => {
    setIsProcessing(true);
    setError(null);
    setResults([]);
    setProcessingStepsList([]);
    setProgress(0);
    setStartTime(Date.now());
    setEstimatedTimeRemaining(null);
    setCanRetry(false);

    // Initialize processing steps
    updateProcessingStep('notes', { 
      status: 'processing'
    });

    addProcessingStep('üöÄ Starting video analysis...', 2);
    addProcessingStep('üîç Validating YouTube URL...', 5);
    addProcessingStep('üìä Extracting video metadata...', 8);
    addProcessingStep('üé¨ Fetching video information...', 12);

    try {
      // Add some realistic processing steps
      await new Promise(resolve => setTimeout(resolve, 1000));
      addProcessingStep('‚úÖ Video validated successfully', 15);
      
      // Fetch video metadata early to show user what's being processed
      try {
        addProcessingStep('üìã Loading video details...', 16);
        const metadataResponse = await fetch('/api/youtube/metadata', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            url: videoUrl.trim()
          }),
        });
        
        if (metadataResponse.ok) {
          const metadata = await metadataResponse.json();
          
          // Format duration
          const duration = metadata.durationSeconds 
            ? `${Math.floor(metadata.durationSeconds / 60)}:${(metadata.durationSeconds % 60).toString().padStart(2, '0')}`
            : 'Unknown';
            
          setVideoMetadata({
            title: metadata.title || 'Unknown Title',
            duration: duration,
            channel: metadata.channelTitle || 'Unknown Channel',
            publishedAt: metadata.publishedAt ? new Date(metadata.publishedAt).toLocaleDateString() : undefined,
            description: metadata.description?.substring(0, 200) + (metadata.description?.length > 200 ? '...' : '')
          });
          
          addProcessingStep(`üì∫ "${metadata.title}" by ${metadata.channelTitle}`, 17);
          addProcessingStep(`‚è±Ô∏è Duration: ${duration}`, 18);
        }
      } catch (metadataError) {
        console.log('Metadata fetch failed, continuing with processing');
      }
      
      await new Promise(resolve => setTimeout(resolve, 800));
      addProcessingStep('üîÑ Determining optimal processing method...', 20);
      
      await new Promise(resolve => setTimeout(resolve, 600));
      addProcessingStep('üéØ Hybrid processing mode selected', 24);
      
      await new Promise(resolve => setTimeout(resolve, 500));
      addProcessingStep('üöÄ Initializing AI analysis pipeline...', 28);

      // üöÄ STEP 1: Process all selected templates
      addProcessingStep(`üìù Processing ${selectedTemplates.length} note format${selectedTemplates.length > 1 ? 's' : ''}...`, 30);
      
      const allResults: ProcessingResult[] = [];
      
      for (let i = 0; i < selectedTemplates.length; i++) {
        const template = selectedTemplates[i];
        setCurrentProcessingIndex(i);
        
        addProcessingStep(`üìã Processing format ${i + 1}/${selectedTemplates.length}: ${template}...`, 30 + (i * 50 / selectedTemplates.length));
        
        const response = await fetch('/api/videos/process', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            videoUrl: videoUrl.trim(),
            selectedTemplate: template,
            processingMode
          }),
        });
        
        const data = await response.json();
        
        if (!response.ok) {
          throw new Error(data.error || `Failed to process ${template} format`);
        }
        
        allResults.push(data);
        addProcessingStep(`‚úÖ ${template} completed`, 30 + ((i + 1) * 50 / selectedTemplates.length));
      }


      // Show completion with technical details
      addProcessingStep(`üìä All ${selectedTemplates.length} format${selectedTemplates.length > 1 ? 's' : ''} completed successfully`, 90);
      
      const firstResult = allResults[0];
      if (firstResult?.processingMethod) {
        addProcessingStep(`üîß Method: ${firstResult.processingMethod}`, 92);
      }
      
      if (firstResult?.dataSourcesUsed) {
        addProcessingStep(`üìã Sources: ${firstResult.dataSourcesUsed.join(', ')}`, 94);
      }
      
      if (firstResult?.tokensUsed) {
        addProcessingStep(`‚ö° Processed ${firstResult.tokensUsed} tokens`, 96);
      }

      addProcessingStep(`‚úÖ Your ${selectedTemplates.length} note format${selectedTemplates.length > 1 ? 's are' : ' is'} ready!`, 100);

      setResults(allResults);
      setCurrentVerbosity('standard');
      
      // Mark notes as complete
      updateProcessingStep('notes', { 
        status: 'complete'
      });
      
      // Share processed notes with chatbot (use first result's content)
      if (onProcessedNotesUpdate && allResults[0]?.content) {
        onProcessedNotesUpdate(allResults[0].content);
      }
      
      // ‚úÖ Show notes immediately to user
      onProcessingComplete?.();
    } catch (err: any) {
      const errorMessage = err.message || 'Something went wrong while converting your video';
      addProcessingStep('‚ùå Conversion failed: ' + errorMessage);
      
      // Enhanced error handling with specific suggestions
      let userFriendlyError = errorMessage;
      let suggestion = '';
      
      if (errorMessage.includes('quota') || errorMessage.includes('429')) {
        userFriendlyError = 'API quota exceeded. Please try again in a few minutes.';
        suggestion = 'This is usually temporary. Please wait a few minutes and try again.';
      } else if (errorMessage.includes('timeout') || errorMessage.includes('deadline')) {
        userFriendlyError = 'Video processing timeout - this video may be too long.';
        suggestion = 'For videos longer than 1 hour, try using the async processing option.';
      } else if (errorMessage.includes('invalid') || errorMessage.includes('400')) {
        userFriendlyError = 'Invalid video URL or content not supported.';
        suggestion = 'Please ensure the YouTube URL is valid and the video is publicly accessible.';
      } else if (errorMessage.includes('size') || errorMessage.includes('too large')) {
        userFriendlyError = 'Video file is too large for processing.';
        suggestion = 'Try using the async processing option for long videos.';
      } else if (errorMessage.includes('pattern') || errorMessage.includes('parsing')) {
        userFriendlyError = 'Video content could not be analyzed.';
        suggestion = 'This may be due to video length, format, or content restrictions.';
      }
      
      setError(userFriendlyError + (suggestion ? `\n\nüí° ${suggestion}` : ''));
      
      // Enable retry for certain error types
      const retryableErrors = ['quota', '429', 'timeout', 'deadline', 'network', 'connection'];
      const isRetryable = retryableErrors.some(errorType => errorMessage.toLowerCase().includes(errorType));
      
      if (isRetryable && retryCount < 2) {
        setCanRetry(true);
      } else {
        setCanRetry(false);
      }
    } finally {
      setIsProcessing(false);
    }
  };

  const retryProcessing = () => {
    setRetryCount(prev => prev + 1);
    setCanRetry(false);
    setError(null);
    handleProcess();
  };

  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text);
  };

  const saveNote = async () => {
    if (!session?.user?.id || results.length === 0) return;

    setIsSavingNote(true);
    setSaveNoteMessage(null);

    try {
      // Save all generated notes
      for (const result of results) {
        const response = await fetch('/api/notes/save', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            title: `${result.title} - ${result.template}`,
            content: result.content,
            templateId: result.template,
            tags: ['youtube', 'ai-generated'],
            youtubeUrl: videoUrl,
            verbosityVersions: result.allVerbosityLevels,
          }),
        });
        
        const data = await response.json();
        
        if (!data.success) {
          throw new Error(data.error || `Failed to save ${result.template} note`);
        }
      }

      setSaveNoteMessage(`All ${results.length} note${results.length > 1 ? 's' : ''} saved successfully!`);
      setTimeout(() => setSaveNoteMessage(null), 3000);
    } catch (error: any) {
      setSaveNoteMessage(error.message || 'Failed to save notes');
      console.error('Error saving notes:', error);
    } finally {
      setIsSavingNote(false);
    }
  };

  const adjustVerbosity = (newVerbosity: 'brief' | 'standard' | 'comprehensive') => {
    if (results.length === 0) return;
    
    setCurrentVerbosity(newVerbosity);
    
    // Update all results with new verbosity
    const updatedResults = results.map(result => {
      const verbosityData = result.allVerbosityLevels;
      if (!verbosityData) return result;
      
      return {
        ...result,
        content: verbosityData[newVerbosity]
      };
    });
    
    setResults(updatedResults);
  };

  if (isProcessing) {

    return (
      <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
        <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-8 max-w-2xl mx-4">
          <div className="text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[var(--accent-pink)] mx-auto mb-6"></div>
            <h3 className="text-xl font-semibold text-[var(--text-primary)] mb-2">Converting Video</h3>
            <p className="text-[var(--text-secondary)] mb-6">
              Processing your video into {selectedTemplates.length} format{selectedTemplates.length > 1 ? 's' : ''}...
            </p>
            
            {/* Show current processing template */}
            {selectedTemplates.length > 1 && (
              <div className="mb-4 p-3 bg-[var(--accent-pink)]/10 border border-[var(--accent-pink)]/20 rounded-lg">
                <p className="text-sm text-[var(--accent-pink)]">
                  Processing {currentProcessingIndex + 1} of {selectedTemplates.length}: {selectedTemplates[currentProcessingIndex]}
                </p>
              </div>
            )}
            
            {/* Simplified Progress Indicator */}
            <div className="mb-6 p-4 bg-[var(--bg-primary)] rounded-lg border border-[var(--card-border)]">
              
              {/* Overall Progress Bar */}
              <div className="w-full bg-[var(--card-border)] rounded-full h-3 mb-3 overflow-hidden">
                <div 
                  className="bg-gradient-to-r from-[var(--accent-pink)] to-[#FF8FB3] h-full rounded-full transition-all duration-500 ease-out"
                  style={{ width: `${progress}%` }}
                />
              </div>
              
              {/* Progress Info */}
              <div className="flex items-center justify-between text-xs">
                <span className="text-[var(--text-secondary)]">{Math.round(progress)}% complete</span>
                {estimatedTimeRemaining !== null && estimatedTimeRemaining > 0 && (
                  <span className="text-[var(--text-secondary)]">
                    ~{Math.round(estimatedTimeRemaining / 1000)}s remaining
                  </span>
                )}
              </div>
            </div>

            {/* Video Metadata Display */}
            {videoMetadata && (
              <div className="mb-4 p-4 bg-[var(--bg-secondary)] rounded-lg border border-[var(--card-border)]">
                <div className="text-left space-y-2">
                  <h4 className="text-sm font-medium text-[var(--text-primary)] mb-2">Processing Video:</h4>
                  <p className="text-sm text-[var(--text-primary)] font-medium truncate" title={videoMetadata.title}>
                    üì∫ {videoMetadata.title}
                  </p>
                  <div className="flex flex-wrap gap-4 text-xs text-[var(--text-secondary)]">
                    <span>‚è±Ô∏è {videoMetadata.duration}</span>
                    <span>üìª {videoMetadata.channel}</span>
                    {videoMetadata.publishedAt && (
                      <span>üìÖ {videoMetadata.publishedAt}</span>
                    )}
                  </div>
                  {videoMetadata.description && (
                    <p className="text-xs text-[var(--text-secondary)] mt-2 leading-relaxed">
                      {videoMetadata.description}
                    </p>
                  )}
                </div>
              </div>
            )}

            {/* Simple Current Status */}
            <div className="text-center p-3 bg-[var(--accent-pink)]/10 border border-[var(--accent-pink)]/20 rounded-lg">
              <p className="text-sm text-[var(--accent-pink)] font-medium">
                {processingStatus}
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
        <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-8 max-w-md mx-4">
          <div className="text-center">
            <div className="text-4xl mb-4">‚ùå</div>
            <h3 className="text-xl font-semibold text-[var(--text-primary)] mb-2">Conversion Failed</h3>
            <p className="text-[var(--text-secondary)] mb-4 whitespace-pre-line">{error}</p>
            <div className="flex gap-3 justify-center">
              {canRetry && (
                <button
                  onClick={retryProcessing}
                  className="px-6 py-2 bg-blue-600 text-white rounded-xl font-semibold hover:bg-blue-700 transition-colors"
                >
                  üîÑ Retry ({2 - retryCount} left)
                </button>
              )}
              <button
                onClick={onClose}
                className="px-6 py-2 bg-[var(--accent-pink)] text-white rounded-xl font-semibold hover:bg-[var(--accent-pink)]/90 transition-colors"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (results.length === 0) return null;

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center overflow-y-auto">
      <div className="bg-[var(--card-bg)] backdrop-blur-[20px] border border-[var(--card-border)] rounded-2xl p-6 max-w-4xl mx-4 my-4 max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <h3 className="text-2xl font-semibold text-[var(--text-primary)]">{results[0].title}</h3>
          <button
            onClick={onClose}
            className="text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors text-2xl"
          >
            ‚úï
          </button>
        </div>
        
        {/* Format tabs when multiple results */}
        {results.length > 1 && (
          <div className="mb-6 flex flex-wrap gap-2">
            {results.map((result, index) => (
              <button
                key={result.template}
                onClick={() => setCurrentProcessingIndex(index)}
                className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${
                  currentProcessingIndex === index
                    ? 'bg-[var(--accent-pink)] text-white'
                    : 'bg-[var(--card-border)] text-[var(--text-secondary)] hover:bg-[var(--accent-pink)]/20'
                }`}
              >
                {result.template}
              </button>
            ))}
          </div>
        )}
        
        {results[currentProcessingIndex].template === 'presentation-slides' ? (
          <PresentationSlides 
            content={results[currentProcessingIndex].content}
            videoUrl={videoUrl}
          />
        ) : (
          <>
            <div className="bg-[var(--bg-primary)] rounded-xl p-6 max-h-96 overflow-y-auto mb-4">
              {showMarkdown ? (
                <div className="text-sm text-[var(--text-primary)] prose prose-invert prose-sm max-w-none">
                  <ReactMarkdown 
                    remarkPlugins={[remarkGfm]}
                    components={{
                      h1: ({children}) => <h1 className="text-xl font-bold text-[var(--text-primary)] mb-4">{children}</h1>,
                      h2: ({children}) => <h2 className="text-lg font-semibold text-[var(--text-primary)] mb-3">{children}</h2>,
                      h3: ({children}) => <h3 className="text-base font-semibold text-[var(--text-primary)] mb-2">{children}</h3>,
                      a: ({href, children}) => {
                        // Check if this is a timestamp link (YouTube URL with timestamp)
                        const isTimestampLink = href && href.includes('youtube.com/watch') && href.includes('&t=');
                        if (isTimestampLink) {
                          return (
                            <a 
                              href={href} 
                              target="_blank" 
                              rel="noopener noreferrer"
                              className="inline-flex items-center px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs font-medium rounded-md transition-colors duration-200 no-underline mx-1"
                              title="Click to jump to this timestamp in the YouTube video"
                            >
                              üîó {children}
                            </a>
                          );
                        }
                        // Regular link styling
                        return <a href={href} className="text-blue-400 hover:text-blue-300 underline" target="_blank" rel="noopener noreferrer">{children}</a>;
                      },
                      p: ({children}) => <p className="mb-3 text-[var(--text-primary)]">{children}</p>,
                      ul: ({children}) => <ul className="list-disc list-inside mb-3 space-y-1">{children}</ul>,
                      ol: ({children}) => <ol className="list-decimal list-inside mb-3 space-y-1">{children}</ol>,
                      li: ({children}) => <li className="ml-4">{children}</li>,
                      strong: ({children}) => <strong className="font-semibold text-[var(--text-primary)]">{children}</strong>,
                      em: ({children}) => <em className="italic">{children}</em>,
                      code: ({children}) => <code className="bg-[var(--card-border)] px-1 py-0.5 rounded text-xs">{children}</code>,
                      pre: ({children}) => <pre className="bg-[var(--card-border)] p-3 rounded-lg overflow-x-auto mb-3">{children}</pre>,
                    }}
                  >
                    {typeof results[currentProcessingIndex].content === 'string' ? results[currentProcessingIndex].content : String(results[currentProcessingIndex].content || '')}
                  </ReactMarkdown>
                </div>
              ) : (
                <pre className="text-sm text-[var(--text-primary)] whitespace-pre-wrap font-mono">
                  {results[currentProcessingIndex].content}
                </pre>
              )}
            </div>


            {/* Verbosity Controls */}
            {results[currentProcessingIndex].allVerbosityLevels && (
              <div className="mb-4 p-4 bg-[var(--bg-primary)] rounded-xl border border-[var(--card-border)]">
                <div className="flex items-center justify-between mb-3">
                  <span className="text-sm font-medium text-[var(--text-primary)]">Adjust Detail Level</span>
                  <span className="text-xs text-[var(--text-secondary)]">Current: {currentVerbosity}</span>
                </div>
                <div className="flex items-center space-x-3">
                  <button
                    onClick={() => adjustVerbosity('brief')}
                    disabled={currentVerbosity === 'brief'}
                    className="px-3 py-1.5 bg-red-500/20 border border-red-500/30 rounded-lg text-xs text-red-400 hover:bg-red-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Brief
                  </button>
                  <button
                    onClick={() => adjustVerbosity('standard')}
                    disabled={currentVerbosity === 'standard'}
                    className="px-3 py-1.5 bg-yellow-500/20 border border-yellow-500/30 rounded-lg text-xs text-yellow-400 hover:bg-yellow-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Standard ‚≠ê
                  </button>
                  <button
                    onClick={() => adjustVerbosity('comprehensive')}
                    disabled={currentVerbosity === 'comprehensive'}
                    className="px-3 py-1.5 bg-green-500/20 border border-green-500/30 rounded-lg text-xs text-green-400 hover:bg-green-500/30 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
                  >
                    Comprehensive
                  </button>
                </div>
              </div>
            )}

            {/* Transcript Viewer */}
            {results[currentProcessingIndex].transcript && (
              <div className="mb-4 p-4 bg-[var(--bg-primary)] rounded-xl border border-[var(--card-border)]">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center space-x-2">
                    <span className="text-sm font-medium text-[var(--text-primary)]">Source Transcript</span>
                    <span className="px-2 py-1 bg-green-500/20 border border-green-500/30 rounded text-xs text-green-400">
                      {results[currentProcessingIndex].processingStats?.method === 'transcript' ? 'Used for Processing' : 'Available'}
                    </span>
                  </div>
                  <button
                    onClick={() => setShowTranscript(!showTranscript)}
                    className="text-xs text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                  >
                    {showTranscript ? 'Hide Transcript' : 'Show Transcript'}
                  </button>
                </div>
                
                {results[currentProcessingIndex].transcript.metadata && (
                  <div className="flex items-center space-x-4 mb-3 text-xs text-[var(--text-secondary)]">
                    <span>üìù {results[currentProcessingIndex].transcript.metadata.wordCount} words</span>
                    <span>‚è±Ô∏è {Math.round(results[currentProcessingIndex].transcript.metadata.duration)}s duration</span>
                    <span>üåê {results[currentProcessingIndex].transcript.metadata.language}</span>
                  </div>
                )}

                {showTranscript && (
                  <div className="max-h-64 overflow-y-auto bg-[var(--card-bg)] rounded-lg p-4 border border-[var(--card-border)]">
                    <div className="space-y-3">
                      {results[currentProcessingIndex].transcript.segments && results[currentProcessingIndex].transcript.segments.length > 0 ? (
                        <div className="space-y-2">
                          <h4 className="text-xs font-medium text-[var(--text-primary)] mb-2">Timestamped Transcript:</h4>
                          {results[currentProcessingIndex].transcript.segments.map((segment, index) => {
                            const minutes = Math.floor(segment.offset / 60);
                            const seconds = Math.floor(segment.offset % 60);
                            const timestamp = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            
                            return (
                              <div key={index} className="flex space-x-3 text-xs">
                                <span className="text-[var(--accent-pink)] font-mono min-w-[45px]">{timestamp}</span>
                                <span className="text-[var(--text-primary)]">{segment.text}</span>
                              </div>
                            );
                          })}
                        </div>
                      ) : (
                        <div>
                          <h4 className="text-xs font-medium text-[var(--text-primary)] mb-2">Full Transcript:</h4>
                          <p className="text-xs text-[var(--text-primary)] leading-relaxed">
                            {results[currentProcessingIndex].transcript.fullText}
                          </p>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Action Buttons */}
            <div className="flex flex-wrap items-center justify-between gap-4 text-sm">
              <div className="flex items-center gap-4">
                <button
                  onClick={() => setShowMarkdown(!showMarkdown)}
                  className={`px-3 py-1 rounded-md transition-all duration-200 text-sm font-medium ${
                    showMarkdown 
                      ? 'text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 hover:bg-[var(--accent-pink)]/10' 
                      : 'bg-orange-500/20 text-orange-400 border border-orange-500/30 hover:bg-orange-500/30'
                  }`}
                >
                  {showMarkdown ? 'üìÑ Show Raw' : 'üîç Show Preview'}
                </button>
                <button
                  onClick={() => copyToClipboard(results[currentProcessingIndex].content)}
                  className="text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                >
                  Copy to Clipboard
                </button>
                {results[currentProcessingIndex].transcript && (
                  <button
                    onClick={() => setShowTranscript(!showTranscript)}
                    className="text-[var(--accent-pink)] hover:text-[var(--accent-pink)]/80 transition-colors"
                  >
                    {showTranscript ? 'Hide Transcript' : 'View Transcript'}
                  </button>
                )}
              </div>
              
              {/* Processing Status Bar and PDF Download Section */}
              <div className="flex flex-col lg:flex-row gap-6 items-start">
                {/* Processing Status Bar */}
                <div className="lg:flex-1">
                  <h4 className="text-sm font-semibold text-[var(--text-primary)] mb-3">
                    Processing Status
                  </h4>
                  <ProcessingStatusBar 
                    steps={processingSteps}
                    compact={false}
                  />
                </div>
                
                {/* PDF Download */}
                <div className="lg:w-64 flex flex-col justify-start">
                  <SimplePdfDownload
                    content={typeof results[currentProcessingIndex].content === 'string' ? results[currentProcessingIndex].content : String(results[currentProcessingIndex].content || '')}
                    title={results[currentProcessingIndex].title}
                    template={results[currentProcessingIndex].template}
                  />
                </div>
              </div>
            </div>

            {/* Ad Banner for Free Users */}
            <ResultsCompletionAd />

            {/* Save Note */}
            {session?.user?.id && (
              <div className="mt-6 flex flex-col items-center space-y-2">
                <button
                  onClick={saveNote}
                  disabled={isSavingNote}
                  className="inline-flex items-center px-6 py-3 bg-green-600 hover:bg-green-700 disabled:bg-green-600/50 text-white font-medium rounded-lg transition-colors duration-200"
                >
                  <svg className="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                  </svg>
                  {isSavingNote ? 'Saving...' : `Save ${results.length} Note${results.length > 1 ? 's' : ''}`}
                </button>
                {saveNoteMessage && (
                  <div className={`text-sm ${saveNoteMessage.includes('successfully') ? 'text-green-400' : 'text-red-400'}`}>
                    {saveNoteMessage}
                  </div>
                )}
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}