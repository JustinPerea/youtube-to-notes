/**
 * YouTube Data API v3 Service
 * 
 * Provides rich video metadata to reduce Gemini API usage
 * Uses YouTube's official API for accurate, comprehensive video data
 */

import { youtube } from '@googleapis/youtube';

// Initialize YouTube API client
const youtubeApi = youtube({
  version: 'v3',
  auth: process.env.YOUTUBE_DATA_API_KEY
});

// Transcript/Caption interfaces
export interface YouTubeCaptionTrack {
  id: string;
  language: string;
  name: string;
  isAutoGenerated: boolean;
  isDefault: boolean;
}

export interface YouTubeTranscriptResult {
  success: boolean;
  transcript?: string;
  segments?: Array<{
    text: string;
    startTime: number;
    endTime: number;
  }>;
  source: 'youtube-captions' | 'gemini' | 'none';
  language?: string;
  isAutoGenerated?: boolean;
  error?: string;
}

export interface YouTubeVideoMetadata {
  // Basic information
  videoId: string;
  title: string;
  description: string;
  channelTitle: string;
  channelId: string;
  publishedAt: string;
  
  // Content details
  duration: string; // ISO 8601 format (e.g., "PT4M13S")
  durationSeconds: number; // Converted to seconds
  dimension: '2d' | '3d';
  definition: 'hd' | 'sd';
  caption: boolean;
  licensedContent: boolean;
  
  // Statistics
  viewCount: number;
  likeCount: number;
  commentCount: number;
  favoriteCount: number;
  
  // Metadata arrays
  tags: string[];
  categoryId: string;
  defaultLanguage?: string;
  
  // Thumbnails
  thumbnails: {
    default?: { url: string; width: number; height: number };
    medium?: { url: string; width: number; height: number };
    high?: { url: string; width: number; height: number };
    standard?: { url: string; width: number; height: number };
    maxres?: { url: string; width: number; height: number };
  };
  
  // Engagement metrics (calculated)
  engagementRate: number; // likes/views ratio
  contentRichness: 'minimal' | 'basic' | 'detailed' | 'comprehensive'; // based on description length
  
  // API metadata
  fetchedAt: Date;
  source: 'youtube-data-api-v3';
}

/**
 * Convert ISO 8601 duration to seconds
 * Converts formats like "PT4M13S" to 253 seconds
 */
function parseDurationToSeconds(duration: string): number {
  const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
  if (!match) return 0;
  
  const hours = parseInt(match[1] || '0', 10);
  const minutes = parseInt(match[2] || '0', 10);
  const seconds = parseInt(match[3] || '0', 10);
  
  return hours * 3600 + minutes * 60 + seconds;
}

/**
 * Determine content richness based on description length and tags
 */
function assessContentRichness(description: string, tags: string[]): YouTubeVideoMetadata['contentRichness'] {
  const descLength = description.length;
  const tagCount = tags.length;
  
  if (descLength >= 1000 && tagCount >= 10) return 'comprehensive';
  if (descLength >= 500 && tagCount >= 5) return 'detailed';
  if (descLength >= 100 && tagCount >= 3) return 'basic';
  return 'minimal';
}

/**
 * Extract YouTube video ID from various URL formats
 */
function extractVideoId(url: string): string | null {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/shorts\/)([^&\n?#]+)/,
    /youtube\.com\/watch\?.*v=([^&\n?#]+)/
  ];
  
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  
  return null;
}

/**
 * Fetch comprehensive video metadata from YouTube Data API v3
 */
export async function fetchVideoMetadata(videoIdOrUrl: string): Promise<YouTubeVideoMetadata | null> {
  try {
    // Extract video ID if URL was provided
    const videoId = videoIdOrUrl.includes('youtube.com') || videoIdOrUrl.includes('youtu.be') 
      ? extractVideoId(videoIdOrUrl)
      : videoIdOrUrl;
    
    if (!videoId) {
      console.error('‚ùå Invalid YouTube video ID or URL:', videoIdOrUrl);
      return null;
    }

    if (!process.env.YOUTUBE_DATA_API_KEY) {
      console.error('‚ùå YOUTUBE_DATA_API_KEY environment variable is required');
      return null;
    }

    console.log('üîç Fetching YouTube metadata for video:', videoId);
    
    // Fetch video data from YouTube Data API v3
    const response = await youtubeApi.videos.list({
      part: ['snippet', 'contentDetails', 'statistics'],
      id: [videoId],
      fields: 'items(id,snippet(title,description,channelTitle,channelId,publishedAt,tags,categoryId,defaultLanguage,thumbnails),contentDetails(duration,dimension,definition,caption,licensedContent),statistics(viewCount,likeCount,dislikeCount,favoriteCount,commentCount))'
    });

    if (!response.data.items || response.data.items.length === 0) {
      console.error('‚ùå Video not found or is private:', videoId);
      return null;
    }

    const video = response.data.items[0];
    const snippet = video.snippet!;
    const contentDetails = video.contentDetails!;
    const statistics = video.statistics!;

    // Parse and calculate derived values
    const durationSeconds = parseDurationToSeconds(contentDetails.duration || 'PT0S');
    const viewCount = parseInt(statistics.viewCount || '0', 10);
    const likeCount = parseInt(statistics.likeCount || '0', 10);
    const engagementRate = viewCount > 0 ? likeCount / viewCount : 0;
    
    const tags = snippet.tags || [];
    const description = snippet.description || '';
    const contentRichness = assessContentRichness(description, tags);

    const metadata: YouTubeVideoMetadata = {
      // Basic information
      videoId,
      title: snippet.title || 'Untitled Video',
      description,
      channelTitle: snippet.channelTitle || 'Unknown Channel',
      channelId: snippet.channelId || '',
      publishedAt: snippet.publishedAt || new Date().toISOString(),
      
      // Content details
      duration: contentDetails.duration || 'PT0S',
      durationSeconds,
      dimension: (contentDetails.dimension as '2d' | '3d') || '2d',
      definition: (contentDetails.definition as 'hd' | 'sd') || 'sd',
      caption: contentDetails.caption === 'true',
      licensedContent: contentDetails.licensedContent || false,
      
      // Statistics
      viewCount,
      likeCount,
      commentCount: parseInt(statistics.commentCount || '0', 10),
      favoriteCount: parseInt(statistics.favoriteCount || '0', 10),
      
      // Metadata arrays
      tags,
      categoryId: snippet.categoryId || '0',
      defaultLanguage: snippet.defaultLanguage || undefined,
      
      // Thumbnails - safely convert null values to undefined
      thumbnails: snippet.thumbnails ? {
        default: snippet.thumbnails.default ? {
          url: snippet.thumbnails.default.url || '',
          width: snippet.thumbnails.default.width || 0,
          height: snippet.thumbnails.default.height || 0
        } : undefined,
        medium: snippet.thumbnails.medium ? {
          url: snippet.thumbnails.medium.url || '',
          width: snippet.thumbnails.medium.width || 0,
          height: snippet.thumbnails.medium.height || 0
        } : undefined,
        high: snippet.thumbnails.high ? {
          url: snippet.thumbnails.high.url || '',
          width: snippet.thumbnails.high.width || 0,
          height: snippet.thumbnails.high.height || 0
        } : undefined,
        standard: snippet.thumbnails.standard ? {
          url: snippet.thumbnails.standard.url || '',
          width: snippet.thumbnails.standard.width || 0,
          height: snippet.thumbnails.standard.height || 0
        } : undefined,
        maxres: snippet.thumbnails.maxres ? {
          url: snippet.thumbnails.maxres.url || '',
          width: snippet.thumbnails.maxres.width || 0,
          height: snippet.thumbnails.maxres.height || 0
        } : undefined,
      } : {},
      
      // Calculated metrics
      engagementRate,
      contentRichness,
      
      // API metadata
      fetchedAt: new Date(),
      source: 'youtube-data-api-v3'
    };

    console.log(`‚úÖ YouTube metadata fetched for "${metadata.title}"`);
    console.log(`   Duration: ${Math.round(durationSeconds / 60)}m ${durationSeconds % 60}s`);
    console.log(`   Views: ${viewCount.toLocaleString()}, Likes: ${likeCount.toLocaleString()}`);
    console.log(`   Description: ${description.length} chars, Tags: ${tags.length}`);
    console.log(`   Content richness: ${contentRichness}`);
    console.log(`   Has captions: ${metadata.caption}`);

    return metadata;

  } catch (error: any) {
    console.error('‚ùå YouTube Data API error:', error);
    
    // Provide specific error messages
    if (error.code === 403) {
      console.error('   API key may be invalid or quota exceeded');
    } else if (error.code === 404) {
      console.error('   Video not found or is private');
    } else if (error.message?.includes('quota')) {
      console.error('   YouTube Data API quota exceeded');
    }
    
    return null;
  }
}

/**
 * Batch fetch metadata for multiple videos (up to 50 at once)
 */
export async function fetchMultipleVideoMetadata(videoIds: string[]): Promise<YouTubeVideoMetadata[]> {
  try {
    if (videoIds.length === 0) return [];
    
    // YouTube Data API allows up to 50 videos per request
    const batchSize = 50;
    const results: YouTubeVideoMetadata[] = [];
    
    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      console.log(`üîç Fetching batch ${Math.floor(i/batchSize) + 1} (${batch.length} videos)`);
      
      const response = await youtubeApi.videos.list({
        part: ['snippet', 'contentDetails', 'statistics'],
        id: batch,
        fields: 'items(id,snippet(title,description,channelTitle,channelId,publishedAt,tags,categoryId,defaultLanguage,thumbnails),contentDetails(duration,dimension,definition,caption,licensedContent),statistics(viewCount,likeCount,dislikeCount,favoriteCount,commentCount))'
      });

      if (response.data.items) {
        for (const video of response.data.items) {
          const videoId = video.id!;
          const snippet = video.snippet!;
          const contentDetails = video.contentDetails!;
          const statistics = video.statistics!;

          const durationSeconds = parseDurationToSeconds(contentDetails.duration || 'PT0S');
          const viewCount = parseInt(statistics.viewCount || '0', 10);
          const likeCount = parseInt(statistics.likeCount || '0', 10);
          const engagementRate = viewCount > 0 ? likeCount / viewCount : 0;
          
          const tags = snippet.tags || [];
          const description = snippet.description || '';
          const contentRichness = assessContentRichness(description, tags);

          results.push({
            videoId,
            title: snippet.title || 'Untitled Video',
            description,
            channelTitle: snippet.channelTitle || 'Unknown Channel',
            channelId: snippet.channelId || '',
            publishedAt: snippet.publishedAt || new Date().toISOString(),
            duration: contentDetails.duration || 'PT0S',
            durationSeconds,
            dimension: (contentDetails.dimension as '2d' | '3d') || '2d',
            definition: (contentDetails.definition as 'hd' | 'sd') || 'sd',
            caption: contentDetails.caption === 'true',
            licensedContent: contentDetails.licensedContent || false,
            viewCount,
            likeCount,
            commentCount: parseInt(statistics.commentCount || '0', 10),
            favoriteCount: parseInt(statistics.favoriteCount || '0', 10),
            tags,
            categoryId: snippet.categoryId || '0',
            defaultLanguage: snippet.defaultLanguage || undefined,
            thumbnails: snippet.thumbnails ? {
              default: snippet.thumbnails.default ? {
                url: snippet.thumbnails.default.url || '',
                width: snippet.thumbnails.default.width || 0,
                height: snippet.thumbnails.default.height || 0
              } : undefined,
              medium: snippet.thumbnails.medium ? {
                url: snippet.thumbnails.medium.url || '',
                width: snippet.thumbnails.medium.width || 0,
                height: snippet.thumbnails.medium.height || 0
              } : undefined,
              high: snippet.thumbnails.high ? {
                url: snippet.thumbnails.high.url || '',
                width: snippet.thumbnails.high.width || 0,
                height: snippet.thumbnails.high.height || 0
              } : undefined,
              standard: snippet.thumbnails.standard ? {
                url: snippet.thumbnails.standard.url || '',
                width: snippet.thumbnails.standard.width || 0,
                height: snippet.thumbnails.standard.height || 0
              } : undefined,
              maxres: snippet.thumbnails.maxres ? {
                url: snippet.thumbnails.maxres.url || '',
                width: snippet.thumbnails.maxres.width || 0,
                height: snippet.thumbnails.maxres.height || 0
              } : undefined,
            } : {},
            engagementRate,
            contentRichness,
            fetchedAt: new Date(),
            source: 'youtube-data-api-v3'
          });
        }
      }
    }

    console.log(`‚úÖ Fetched metadata for ${results.length}/${videoIds.length} videos`);
    return results;

  } catch (error) {
    console.error('‚ùå Batch YouTube metadata fetch error:', error);
    return [];
  }
}

/**
 * Assess video content quality and provide recommendations (but don't force skip)
 * Users should have the choice to process any video they want
 */
export function assessVideoContent(metadata: YouTubeVideoMetadata, options: {
  enableSmartFiltering?: boolean;
  minDuration?: number;
  requireCaptions?: boolean;
} = {}): {
  shouldSkip: boolean;
  reason: string;
  recommendation: 'process' | 'consider_skipping' | 'low_quality';
  qualityScore: number; // 0-100
} {
  const { 
    enableSmartFiltering = false,  // Default: don't skip, let users decide
    minDuration = 15,              // Very short threshold (15 seconds)
    requireCaptions = false 
  } = options;
  
  let qualityScore = 50; // Start with neutral score
  let recommendation: 'process' | 'consider_skipping' | 'low_quality' = 'process';
  let issues: string[] = [];
  
  // Assess duration
  if (metadata.durationSeconds < 15) {
    qualityScore -= 30;
    issues.push('very short video (< 15s)');
    recommendation = 'low_quality';
  } else if (metadata.durationSeconds < 60) {
    qualityScore -= 10;
    issues.push('short video (< 1min)');
  } else {
    qualityScore += 10;
  }
  
  // Assess content richness
  switch (metadata.contentRichness) {
    case 'comprehensive':
      qualityScore += 20;
      break;
    case 'detailed':
      qualityScore += 10;
      break;
    case 'basic':
      // neutral
      break;
    case 'minimal':
      qualityScore -= 15;
      issues.push('minimal description and tags');
      if (recommendation === 'process') recommendation = 'consider_skipping';
      break;
  }
  
  // Assess captions availability
  if (metadata.caption) {
    qualityScore += 15;
  } else {
    qualityScore -= 10;
    issues.push('no captions available');
    if (requireCaptions) {
      recommendation = 'consider_skipping';
    }
  }
  
  // Assess engagement
  if (metadata.viewCount > 10000) {
    qualityScore += 5;
  }
  
  // Final assessment
  qualityScore = Math.max(0, Math.min(100, qualityScore));
  
  // Only skip if explicitly enabled AND meets skip criteria
  const shouldSkip = enableSmartFiltering && (
    (metadata.durationSeconds < minDuration) ||
    (requireCaptions && !metadata.caption && metadata.description.length < 100)
  );
  
  const reason = shouldSkip 
    ? `Smart filtering enabled: ${issues.join(', ')}`
    : issues.length > 0 
      ? `Quality concerns: ${issues.join(', ')} (but processing allowed)`
      : 'Good quality video for processing';
  
  return {
    shouldSkip,
    reason,
    recommendation,
    qualityScore
  };
}

/**
 * Generate enhanced context for Gemini API using YouTube metadata
 */
export function generateEnhancedContext(metadata: YouTubeVideoMetadata): string {
  const context = [
    `Video: "${metadata.title}" by ${metadata.channelTitle}`,
    `Duration: ${Math.floor(metadata.durationSeconds / 60)}:${(metadata.durationSeconds % 60).toString().padStart(2, '0')}`,
    `Published: ${new Date(metadata.publishedAt).toLocaleDateString()}`,
    `Views: ${metadata.viewCount.toLocaleString()}`,
    `Engagement: ${(metadata.engagementRate * 100).toFixed(3)}% like rate`
  ];
  
  if (metadata.tags.length > 0) {
    context.push(`Tags: ${metadata.tags.slice(0, 10).join(', ')}`);
  }
  
  if (metadata.description.length > 100) {
    // Include first 500 characters of description for context
    const descPreview = metadata.description.substring(0, 500) + 
      (metadata.description.length > 500 ? '...' : '');
    context.push(`Description: ${descPreview}`);
  }
  
  return context.join('\n');
}

/**
 * List available caption tracks for a video using YouTube Data API v3
 */
export async function listCaptionTracks(videoId: string): Promise<YouTubeCaptionTrack[]> {
  try {
    if (!process.env.YOUTUBE_DATA_API_KEY) {
      console.error('‚ùå YOUTUBE_DATA_API_KEY required for caption access');
      return [];
    }

    console.log('üîç Listing available caption tracks for video:', videoId);

    const response = await youtubeApi.captions.list({
      part: ['snippet'],
      videoId: videoId
    });

    if (!response.data.items) {
      console.log('‚ö†Ô∏è No caption tracks found');
      return [];
    }

    const tracks: YouTubeCaptionTrack[] = response.data.items.map(item => ({
      id: item.id!,
      language: item.snippet!.language!,
      name: item.snippet!.name!,
      isAutoGenerated: item.snippet!.trackKind === 'asr', // ASR = Automatic Speech Recognition
      isDefault: item.snippet!.language === 'en' // Default to English if available
    }));

    console.log(`‚úÖ Found ${tracks.length} caption tracks:`, 
      tracks.map(t => `${t.language}(${t.isAutoGenerated ? 'auto' : 'manual'})`).join(', '));

    return tracks;

  } catch (error: any) {
    console.error('‚ùå Error listing caption tracks:', error.message);
    return [];
  }
}

/**
 * Download caption content using YouTube Data API v3
 */
export async function downloadCaptions(captionId: string): Promise<string | null> {
  try {
    if (!process.env.YOUTUBE_DATA_API_KEY) {
      console.error('‚ùå YOUTUBE_DATA_API_KEY required for caption download');
      return null;
    }

    console.log('üì• Downloading caption content for ID:', captionId);

    const response = await youtubeApi.captions.download({
      id: captionId,
      tfmt: 'srt' // SubRip format - includes timestamps
    });

    if (response.data) {
      console.log('‚úÖ Caption content downloaded successfully');
      return response.data as string;
    }

    return null;

  } catch (error: any) {
    console.error('‚ùå Error downloading captions:', error.message);
    return null;
  }
}

/**
 * Parse SRT format captions into structured segments
 */
function parseSRTCaptions(srtContent: string): Array<{
  text: string;
  startTime: number;
  endTime: number;
}> {
  const segments: Array<{ text: string; startTime: number; endTime: number }> = [];
  const blocks = srtContent.split(/\n\s*\n/);

  for (const block of blocks) {
    const lines = block.trim().split('\n');
    if (lines.length < 3) continue;

    // Parse timestamp line (format: "00:00:01,234 --> 00:00:04,567")
    const timestampMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
    if (!timestampMatch) continue;

    const startTime = 
      parseInt(timestampMatch[1]) * 3600 + 
      parseInt(timestampMatch[2]) * 60 + 
      parseInt(timestampMatch[3]) + 
      parseInt(timestampMatch[4]) / 1000;

    const endTime = 
      parseInt(timestampMatch[5]) * 3600 + 
      parseInt(timestampMatch[6]) * 60 + 
      parseInt(timestampMatch[7]) + 
      parseInt(timestampMatch[8]) / 1000;

    // Combine text lines (skip sequence number and timestamp)
    const text = lines.slice(2).join(' ').replace(/<[^>]*>/g, ''); // Remove HTML tags

    segments.push({
      text: text.trim(),
      startTime,
      endTime
    });
  }

  return segments;
}

/**
 * Extract transcript using official YouTube Data API v3 Captions
 */
export async function extractYouTubeTranscript(videoId: string): Promise<YouTubeTranscriptResult> {
  try {
    console.log('üéØ Starting official YouTube caption extraction...');
    
    // List available caption tracks
    const captionTracks = await listCaptionTracks(videoId);
    
    if (captionTracks.length === 0) {
      return {
        success: false,
        source: 'none',
        error: 'No captions available for this video'
      };
    }

    // Prioritize caption tracks (English manual > English auto > other manual > other auto)
    const prioritizedTracks = captionTracks.sort((a, b) => {
      if (a.language === 'en' && b.language !== 'en') return -1;
      if (b.language === 'en' && a.language !== 'en') return 1;
      if (!a.isAutoGenerated && b.isAutoGenerated) return -1;
      if (!b.isAutoGenerated && a.isAutoGenerated) return 1;
      return 0;
    });

    const selectedTrack = prioritizedTracks[0];
    console.log(`üìù Selected caption track: ${selectedTrack.language} (${selectedTrack.isAutoGenerated ? 'auto-generated' : 'manual'})`);

    // Download caption content
    const srtContent = await downloadCaptions(selectedTrack.id);
    
    if (!srtContent) {
      return {
        success: false,
        source: 'youtube-captions',
        error: 'Failed to download caption content'
      };
    }

    // Parse SRT content into segments
    const segments = parseSRTCaptions(srtContent);
    const transcript = segments.map(s => s.text).join(' ');

    console.log(`‚úÖ Official YouTube transcript extracted: ${segments.length} segments, ${transcript.length} characters`);

    return {
      success: true,
      transcript,
      segments,
      source: 'youtube-captions',
      language: selectedTrack.language,
      isAutoGenerated: selectedTrack.isAutoGenerated
    };

  } catch (error: any) {
    console.error('‚ùå Official YouTube caption extraction failed:', error.message);
    
    return {
      success: false,
      source: 'youtube-captions',
      error: error.message || 'Unknown error during caption extraction'
    };
  }
}

/**
 * Enhanced transcript extraction with official YouTube API + Gemini fallback
 * This replaces the third-party youtube-transcript package approach
 */
export async function extractTranscriptEnhanced(videoIdOrUrl: string): Promise<YouTubeTranscriptResult> {
  try {
    // Extract video ID if URL was provided
    const videoId = videoIdOrUrl.includes('youtube.com') || videoIdOrUrl.includes('youtu.be') 
      ? extractVideoId(videoIdOrUrl)
      : videoIdOrUrl;
    
    if (!videoId) {
      return {
        success: false,
        source: 'none',
        error: 'Invalid YouTube video ID or URL'
      };
    }

    console.log('üéØ Starting enhanced transcript extraction with official APIs...');
    console.log('üìã Strategy: YouTube Captions API ‚Üí Gemini Generation ‚Üí None');

    // Step 1: Try official YouTube Data API v3 captions
    const youtubeResult = await extractYouTubeTranscript(videoId);
    
    if (youtubeResult.success) {
      console.log(`‚úÖ Official YouTube captions successful: ${youtubeResult.transcript?.length} characters`);
      return youtubeResult;
    }

    console.log(`‚ö†Ô∏è YouTube captions failed: ${youtubeResult.error}`);
    console.log('üîÑ Attempting Gemini video analysis for transcript generation...');

    // Step 2: Fall back to Gemini video analysis (as you confirmed it can analyze video content)
    try {
      const { geminiClient } = await import('@/lib/gemini/client');
      const videoUrl = videoIdOrUrl.includes('http') ? videoIdOrUrl : `https://www.youtube.com/watch?v=${videoId}`;
      
      const geminiResult = await geminiClient.generateTranscriptFromVideo(videoUrl);
      
      if (geminiResult.success && geminiResult.transcript) {
        console.log(`‚úÖ Gemini video analysis successful: ${geminiResult.transcript.length} characters`);
        
        return {
          success: true,
          transcript: geminiResult.transcript,
          segments: geminiResult.segments || [],
          source: 'gemini',
          language: 'en',
          isAutoGenerated: true
        };
      }

      console.log(`‚ö†Ô∏è Gemini video analysis failed: ${geminiResult.error}`);
      
    } catch (geminiError: any) {
      console.error('‚ùå Gemini fallback error:', geminiError.message);
    }

    // Step 3: No transcript available
    return {
      success: false,
      source: 'none',
      error: `Complete transcript extraction failure. YouTube: ${youtubeResult.error}, Gemini: video analysis unavailable`
    };

  } catch (error: any) {
    console.error('‚ùå Enhanced transcript extraction error:', error.message);
    
    return {
      success: false,
      source: 'none',
      error: error.message || 'Unknown error during enhanced transcript extraction'
    };
  }
}